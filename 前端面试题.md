> **1.v-if与v-for哪个优先级更高？如果两个同时出现，应该如何优化到更好的性能。**

1.v-for优先于v-if被解析（源码中找到了）

2.缺点：如果同时出现，每次渲染都会先执行循环再判断条件，浪费性能

3.解决方案：在v-for的外层嵌套template,template使用v-if判断，然后在内部进行v-for循环



>**2.谈一谈对vue设计原则的理解**

1.渐进式javascript框架（vue的核心库只关注视图层）递进的过程

2.易用（容易上手），灵活（渐进是使用过程）和高效（超快的虚拟DOM和diff算法）



> **3.vue的优点**

1.轻量级框架，大小只有几十kb

2.易用性，简单易学国人开发，易于理解与学习

3.双向数据绑定，在操作数据上更为简单

4.视图，数据，结构分离，数据驱动视图

5.虚拟DOM操作，提升性能

6.运行速度更快

7.组件化在构建化单页面应用上更加有优势



> **4.vue父组件如何向子组件传递数据，子组件如何向父组件传递事件**

父组件通过使用props属性向子组件传递数据，子组件通过使用$emit方法向父组件传递事件



>**5.v-show和v-if的区别**

共同点是都可以控制显示隐藏。

区别在于v-if是通过动态的向DOM添加和删除DOM实现控制，这样频繁的销毁和生成比较消耗性能

v-show是通过控制元素css的display属性来实现的。

如果需要频繁的切换，我会使用v-show，不需要频繁的切换我会用v-if



> **6.如何让css只在当前组件中起作用**

在组件中的style标签中加scoped



> **7.keep-alive的作用是什么**

keep-alive是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。



> **8.vue中如何获取Dom**

在标签中使用ref属性，然后在代码中this.$refs.属性名 这样就拿到了页面元素（ref="domName" 用法：this.$refs.domName）



> **9.v-modal的使用**

v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
v-bind绑定一个value属性；
v-on指令给当前元素绑定input事件。

> **10.mvvm 框架是什么？**

vue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。

> **11.深拷贝浅拷贝** 

浅拷贝：浅拷贝通过ES6新特性Object.assign()或者通过扩展运算法...来达到浅拷贝的目的，浅拷贝修改 副本，不会影响原数据，但缺点是浅拷贝只能拷贝第一层的数据，且都是值类型数据，如果有引用型数据，修改 副本会影响原数据。

深拷贝：通过利用JSON.parse(JSON.stringify())来实现深拷贝的目的，但利用JSON拷贝也是有缺点的， 当要拷贝的数据中含有undefined/function/symbol类型是无法进行拷贝的，当然我们想项目开发中需要 深拷贝的数据一般不会含有以上三种类型，如有需要可以自己在封装一个函数来实现。

>  **12.闭包**

首先说明什么是闭包，闭包简单来说就是函数嵌套函数，内部函数引用来外部函数的变量，从而导致垃圾回收 机制没有把当前变量回收掉，这样的操作带来了内存泄漏的影响，当内存泄漏到一定程度会影响你的项目运行 变得卡顿等等问题。因此在项目中我们要尽量避免内存泄漏。

> **13.原型链**

原型链实际上在上面原型的问题中就有涉及到，在原型的继承中，我们继承来多个原型，这里再提一下实现完美 继承的方案，通过借助寄生组合继承，PersonB.prototype = Object.create(PersonA.prototype) 这是当我们实例化PersonB得到实例化对象，访问实例化对象的属性时会触发get方法，它会先在自身属性上查 找，如果没有这个属性，就会去__proto__中查找，一层层向上直到查找到顶层对象Object，这个查找的过程 就是原型链来。

> **14.vuex**

vuex是一个专为vue.js应用程序开发的状态管理器，它采用集中式存储管理应用的所有组件的状态，并且以相 应的规则保证状态以一种可以预测的方式发生变化。

 state: vuex使用单一状态树，用一个对象就包含来全部的应用层级状态 

mutation: 更改vuex中state的状态的唯一方法就是提交mutation 

action: action提交的是mutation，而不是直接变更状态，action可以包含任意异步操作 

getter: 相当于vue中的computed计算属性

> **15.vue-router**

vue-router是vuex.js官方的路由管理器，它和vue.js的核心深度集成，让构建但页面应用变得易如反掌 

<router-link> 组件支持用户在具有路由功能的应用中 (点击) 导航。 通过 to 属性指定目标地址 

<router-view> 组件是一个 functional 组件，渲染路径匹配到的视图组件。 

<keep-alive> 组件是一个用来缓存组件 

router.beforeEach

router.afterEach 

to: Route: 即将要进入的目标 路由对象 

from: Route: 当前导航正要离开的路由 

next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 

> **16.Vue路由守卫有哪些，怎么设置，使用场景等**

常用的两个路由守卫：router.beforeEach 和 router.afterEach 

每个守卫方法接收三个参数： 

to: Route: 即将要进入的目标 路由对象 

from: Route: 当前导航正要离开的路由 

next: Function: 一定要调用该方法来 resolve 这个钩子。 

在项目中，一般在beforeEach这个钩子函数中进行路由跳转的一些信息判断。 判断是否登录，是否拿到对应的路由权限等等。

> **17.数组去重**

```
第一种： 通过ES6新特性Set()
例如： var arr = [1, 2, 3, 1, 2]; var newArr= [...new Set(arr)]
```

> **18.网页从输入网址到渲染完成经历了哪些过程？**

大致可以分为如下7步：

1. 输入网址；
2. 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；
3. 与web服务器建立TCP连接；
4. 浏览器向web服务器发送http请求；
5. web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；
6. 浏览器下载web服务器返回的数据及解析html源文件；
7. 生成DOM树，解析css和js，渲染页面，直至显示完成；

>  **19**

11122